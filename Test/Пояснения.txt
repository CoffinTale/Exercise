
1 задание:
ћо€ реализаци€:
+ вычисление идет быстрее, потому что происходит побитовое "»".
ѕример:
+ математически более пон€тна€ и логична€ реализаци€.
- при многочисленных определени€х четности врем€ вычислени€ может увеличитс€.

2 задание:
–еализаци€ с помощью массива:
+ очень просто реализовывать.
- количество элементов ограничего размером массива, из-за этого при переполнении приходитс€ перевыдел€ть пам€ть и копировать все элементы в новый массив.
–еализаци€ с помощью списка:
+ кажда€ операци€ выполн€етс€ за врем€ ќ(1).
- пам€ть фрагментируетс€ гораздо сильнее и итерации по такой очереди могут быть ощутимо медленнее, чем итерации по очереди, реализованной на массиве.

3 задание:
јлгоритм сортировки Timsort.
я прочитала статью сравнени€ скорости различных алгоритмов. ¬ ней проводились тесты с разными типами данных: никак не упор€доченные данные, независимые отсортированные группы разного размера,отсортированные группы разных размеров, произвольные перестановки упор€доченных данных.
¬сего 4 теста, в которых 3 раза быстрее всех был Timsort, в последнем он уступил Quicksort. ѕоэтому € сделала вывод, что он €вл€етс€ самым эффективным.ќн основан на двух алгоримах: Merge Sort и Insertion Sort.
Timsort дает заметное ускорение при увеличении степени упор€доченности данных и работает на уровне Quicksort в обычных случах. ќн также используетс€ как стандартный метод сортировки в некоторых яѕ, например в Python.
